# Бибилиотека orjson
orjson — это высокопроизводительная библиотека (написанная на Rust) для сериализации/десериализации JSON в Python, которая работает в 2–11 раз быстрее стандартного модуля json. Она поддерживает сериализацию dataclasses, UUID, datetime и numpy массивов, возвращая bytes вместо строк, что оптимизирует работу

# Зачем нужна orjson?
Основная задача orjson — сериализация (преобразование Python-объектов в JSON) и десериализация (обратное преобразование). Вот ключевые причины выбрать её :

1. Высокая производительность: Написана на Rust (или C, в зависимости от контекста), что делает её в 10+ раз быстрее стандартной библиотеки json при сериализации и в 2+ раза быстрее при парсинге .

2. Поддержка сложных типов: Из коробки умеет сериализовать dataclass, datetime, date, time, UUID, numpy.ndarray, enum.Enum и другие, без необходимости писать кастомные обработчики .

3. Корректность: Строго соблюдает стандарт JSON (RFC 8259) и корректно работает с UTF-8, что позволяет избежать многих скрытых ошибок .

4. Безопасность: Не поддерживает бесконечности (NaN, Infinity), что соответствует спецификации JSON и повышает безопасность обмена данными(Выпускает корректный JSON, строго соблюдая стандарт) .

# Быстрый старт
Устновить библиотеку:
```
pip install orjson
```

Простой пример использования:
```
import orjson

# Данные для сериализации
data = {"name": "John", "age": 30, "city": "New York"}

# Сериализация (Python > JSON bytes)
json_bytes = orjson.dumps(data)
print(json_bytes)  # Вывод: b'{"name":"John","age":30,"city":"New York"}'

# Для получения строки использовать .decode()
json_str = json_bytes.decode()
print(json_str)  # Вывод: {"name":"John","age":30,"city":"New York"}

# Десериализация (JSON bytes > Python dict)
data_again = orjson.loads(json_bytes)
print(data_again) # Вывод: {'name': 'John', 'age': 30, 'city': 'New York'}
```

# Основные сущности и функции
Библиотека orjson имеет простой и понятный API, состоящий из двух основных функций и набора констант-опций.
### 1. Функции сериализации и десериализации
------------------------------------------------------------------------------------------------------------------------
* **orjson.dumps(obj, default=None, option=None)**

**Назначение:** Преобразует Python-объект obj в JSON.

**Возвращаемое значение:** Всегда возвращает bytes, а не строку (str), как стандартный json.dumps() . Это важное отличие.

**Параметры:**
1. default: функция для обработки типов, не поддерживаемых напрямую .
2. option: целочисленный флаг (или комбинация флагов), меняющий поведение сериализации .
------------------------------------------------------------------------------------------------------------------------
* **orjson.loads(json_data)**

**Назначение:** Преобразует JSON-данные обратно в Python-объект.

**Параметры:** Принимает на вход bytes, str или другие буфероподобные объекты, содержащие корректный UTF-8 JSON .


### 2. Ключевые опции (Flags)

**Опции позволяют тонко настроить процесс сериализации. Их можно комбинировать с помощью оператора |**

Опция(orjson.) ->	Назначение
* **orjson.OPT_INDENT_2** ->	Форматирует вывод с отступами в 2 пробела (аналог indent=2 в json);
```
print(orjson.dumps({"a":1,"b":2}, option=orjson.OPT_INDENT_2).decode()) 
```
* **orjson.OPT_SORT_KEYS** ->	Сортирует ключи в словарях при выводе (аналог sort_keys=True);
```
print(orjson.dumps({"c":3, "a":1, "b":2}, option=orjson.OPT_SORT_KEYS).decode())  # {"a":1,"b":2,"c":3}
```
* **orjson.OPT_OMIT_MICROSECONDS** ->	При сериализации datetime отбрасывает микросекунды;
```
print(orjson.dumps({"time": datetime.datetime.now()}, option=orjson.OPT_OMIT_MICROSECONDS).decode())  # Без .xxxxxx
```
* **orjson.OPT_NON_STR_KEYS** ->	Позволяет использовать в словарях ключи не только строкового типа (например, числа), которые будут автоматически преобразованы в строки;
```
print(orjson.dumps({1: "one", 2: "two"}, option=orjson.OPT_NON_STR_KEYS).decode())  # {"1":"one","2":"two"}
```
* **orjson.OPT_SERIALIZE_NUMPY** ->	Включает поддержку сериализации numpy типов (например, ndarray). Без этой опции numpy-объекты вызовут ошибку;
```
print(orjson.dumps({"arr": np.array([1,2,3])}, option=orjson.OPT_SERIALIZE_NUMPY).decode())  # {"arr":[1,2,3]}
```
* **orjson.OPT_NAIVE_UTC**	Интерпретирует "наивные" (не зависящие от часового пояса) объекты datetime как UTC.
```
print(orjson.dumps({"time": datetime.datetime(2024,1,1,12,0)}, option=orjson.OPT_NAIVE_UTC).decode())  # с Z в конце
```

**Пример комбинирования нескольких опций через |:**
```
data = {"c": 3, "a": 1, "b": 2}
print(orjson.dumps(
    data, 
    option=orjson.OPT_SORT_KEYS | orjson.OPT_INDENT_2
).decode())
# Вывод с сортировкой и отступами
```
### 3. Вспомогательные сущности

* **orjson.Fragment** -> Позволяет вставить уже готовый JSON-фрагмент (в виде bytes) в итоговый JSON-документ. Это очень полезно для оптимизации, когда у вас есть предварительно сериализованные данные (например, из кэша), которые не нужно парсить и сериализовать заново.
**Пример:**
```
precomputed = b'{"id": 1, "data": "precomputed"}'
data = {"metadata": orjson.Fragment(precomputed), "status": "ok"}
print(orjson.dumps(data).decode())
# Вывод: {"metadata":{"id": 1, "data": "precomputed"},"status":"ok"}
```

**Исключения:**

* **orjson.JSONEncodeError**: Наследник TypeError. Возникает при ошибках в процессе сериализации (например, неподдерживаемый тип, некорректная UTF-8 строка, слишком большое число) .

* **orjson.JSONDecodeError**: Возникает при ошибках десериализации, если входные данные не являются корректным JSON .
