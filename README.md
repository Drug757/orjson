# Бибилиотека orjson
orjson — это быстрая и правильная Python-библиотека для работы с JSON, которая значительно превосходит стандартную библиотеку json по скорости и обладает расширенными возможностями. Она идеально подходит для приложений, где производительность критична, и для работы со сложными типами данных, такими как datetime, numpy и dataclass

# Зачем нужна orjson?
Основная задача orjson — сериализация (преобразование Python-объектов в JSON) и десериализация (обратное преобразование). Вот ключевые причины выбрать её :

1. Высокая производительность: Написана на Rust (или C, в зависимости от контекста), что делает её в 10+ раз быстрее стандартной библиотеки json при сериализации и в 2+ раза быстрее при парсинге .

2. Поддержка сложных типов: Из коробки умеет сериализовать dataclass, datetime, date, time, UUID, numpy.ndarray, enum.Enum и другие, без необходимости писать кастомные обработчики .

3. Корректность: Строго соблюдает стандарт JSON (RFC 8259) и корректно работает с UTF-8, что позволяет избежать многих скрытых ошибок .

4. Безопасность: Не поддерживает бесконечности (NaN, Infinity), что соответствует спецификации JSON и повышает безопасность обмена данными .

# Быстрый старт
Устновить библиотеку:
```
pip install orjson
```

Простой пример использования:
```
import orjson

# Данные для сериализации
data = {"name": "John", "age": 30, "city": "New York"}

# Сериализация (Python > JSON bytes)
json_bytes = orjson.dumps(data)
print(json_bytes)  # Вывод: b'{"name":"John","age":30,"city":"New York"}'

# Для получения строки использовать .decode()
json_str = json_bytes.decode()
print(json_str)  # Вывод: {"name":"John","age":30,"city":"New York"}

# Десериализация (JSON bytes > Python dict)
data_again = orjson.loads(json_bytes)
print(data_again) # Вывод: {'name': 'John', 'age': 30, 'city': 'New York'}
```

# Основные сущности и функции
Библиотека orjson имеет простой и понятный API, состоящий из двух основных функций и набора констант-опций.
### 1. Функции сериализации и десериализации
------------------------------------------------------------------------------------------------------------------------
* **orjson.dumps(obj, default=None, option=None)**

**Назначение:** Преобразует Python-объект obj в JSON.

**Возвращаемое значение:** Всегда возвращает bytes, а не строку (str), как стандартный json.dumps() . Это важное отличие.

**Параметры:**
1. default: функция для обработки типов, не поддерживаемых напрямую .
2. option: целочисленный флаг (или комбинация флагов), меняющий поведение сериализации .
------------------------------------------------------------------------------------------------------------------------
* **orjson.loads(json_data)**

**Назначение:** Преобразует JSON-данные обратно в Python-объект.

**Параметры:** Принимает на вход bytes, str или другие буфероподобные объекты, содержащие корректный UTF-8 JSON .


### 2. Ключевые опции (Flags)

**Опции позволяют тонко настроить процесс сериализации. Их можно комбинировать с помощью оператора |**

Опция(orjson.) ->	Назначение
* **orjson.OPT_INDENT_2** ->	Форматирует вывод с отступами в 2 пробела (аналог indent=2 в json);
* **orjson.OPT_SORT_KEYS** ->	Сортирует ключи в словарях при выводе (аналог sort_keys=True);
* **orjson.OPT_OMIT_MICROSECONDS** ->	При сериализации datetime отбрасывает микросекунды;
* **orjson.OPT_NON_STR_KEYS** ->	Позволяет использовать в словарях ключи не только строкового типа (например, числа), которые будут автоматически преобразованы в строки;
* **orjson.OPT_SERIALIZE_NUMPY** ->	Включает поддержку сериализации numpy типов (например, ndarray). Без этой опции numpy-объекты вызовут ошибку;
* **orjson.OPT_NAIVE_UTC**	Интерпретирует "наивные" (не зависящие от часового пояса) объекты datetime как UTC.

### 3. Вспомогательные сущности

* **orjson.Fragment** -> Позволяет вставить уже готовый JSON-фрагмент (в виде bytes) в итоговый JSON-документ. Это очень полезно для оптимизации, когда у вас есть предварительно сериализованные данные (например, из кэша), которые не нужно парсить и сериализовать заново.
**Пример:**
```
precomputed = b'{"id": 1, "data": "precomputed"}'
data = {"metadata": orjson.Fragment(precomputed), "status": "ok"}
print(orjson.dumps(data).decode())
# Вывод: {"metadata":{"id": 1, "data": "precomputed"},"status":"ok"}
```

* **Исключения:**

**orjson.JSONEncodeError**: Наследник TypeError. Возникает при ошибках в процессе сериализации (например, неподдерживаемый тип, некорректная UTF-8 строка, слишком большое число) .

**orjson.JSONDecodeError**: Возникает при ошибках десериализации, если входные данные не являются корректным JSON .
